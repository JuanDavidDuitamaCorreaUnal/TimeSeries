plot_seasonal_diagnostics(.date_var = index, .value = Diferencia, .feature_set = c("quarter"), .geom = "boxplot")
ggplot(PIB_tsibble %>%na.omit()|>
mutate(
Trimestre = str_c("Trimestre ", as.character(lubridate::quarter(index)))
), aes(x = Diferencia)) +
geom_density(aes(fill = Trimestre)) +
ggtitle("LosPass - Estimación de la densidad vía Kernel por trimestre") +
facet_grid(rows = vars(as.factor(Trimestre)))
ggplot(PIB_tsibble %>%na.omit()|>
mutate(
Trimestre = str_c("Trimestre ", as.character(lubridate::quarter(index)))
), aes(x = Diferencia)) +
geom_density(aes(fill = Trimestre)) +
ggtitle("Estimación de la densidad vía Kernel por trimestre") +
facet_grid(rows = vars(as.factor(Trimestre)))
#Diferencia ordinaria
PeriodgramadTra=spectrum(as.numeric(Dif_ord_PIB),log='no')
ubicacion=which.max(PeriodgramadTra$spec)
sprintf("El valor de la frecuencia donde se máximiza el periodograma para la serie con tendencia extraída por diferencia ordinaria es: %s",PeriodgramadTra$freq[ubicacion])
sprintf("El periodo correspondiente es aproximadamente: %s",1/PeriodgramadTra$freq[ubicacion])
DiferTSibl<-as_tsibble(Dif_ord_PIB)
DiferTSibl
###Explore diferentes valores de K
Modelo_serie_diff<-DiferTSibl|>model(
`Fourier1Desempleo`=ARIMA(value~fourier(K=4)+pdq(0, 0, 0) + PDQ(0, 0, 0))#En este caso se hace con tres componentes de Fourier
)
real_ajustado1<-DiferTSibl%>%left_join(fitted(Modelo_serie_diff,by=index))#%>%select(-.model)
plot_ly(x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado1$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Armónico") %>%
layout(title = 'Tasa de Desempleo sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
DiferTSibl<-as_tsibble(Dif_ord_PIB)
DiferTSibl
###Explore diferentes valores de K
Modelo_serie_diff<-DiferTSibl|>model(
`Fourier1Desempleo`=ARIMA(value~fourier(K=4)+pdq(0, 0, 0) + PDQ(0, 0, 0))#En este caso se hace con tres componentes de Fourier
)
real_ajustado1<-DiferTSibl%>%left_join(fitted(Modelo_serie_diff,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado1$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Armónico") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#####Ajuste Dummy
ModeloDummy<-DiferTSibl|>model(
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado2<-DiferTSibl%>%left_join(fitted(ModeloDummy,by=index))#%>%select(-.model)
plot_ly(x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado2$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Dummy") %>%
layout(title = 'Tasa de Desempleo sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
DiferTSibl<-as_tsibble(Dif_ord_PIB)
DiferTSibl
###Explore diferentes valores de K
Modelo_serie_diff<-DiferTSibl|>model(
`Fourier1Desempleo`=ARIMA(value~fourier(K=4)+pdq(0, 0, 0) + PDQ(0, 0, 0))#En este caso se hace con tres componentes de Fourier
)
real_ajustado1<-DiferTSibl%>%left_join(fitted(Modelo_serie_diff,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado1$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Armónico") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#####Ajuste Dummy
ModeloDummy<-DiferTSibl|>model(
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado2<-DiferTSibl%>%left_join(fitted(ModeloDummy,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB), type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
DiferTSibl<-as_tsibble(Dif_ord_PIB)
DiferTSibl
###Explore diferentes valores de K
Modelo_serie_diff<-DiferTSibl|>model(
`Fourier1Desempleo`=ARIMA(value~fourier(K=4)+pdq(0, 0, 0) + PDQ(0, 0, 0))#En este caso se hace con tres componentes de Fourier
)
real_ajustado1<-DiferTSibl%>%left_join(fitted(Modelo_serie_diff,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado1$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Armónico") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#####Ajuste Dummy
ModeloDummy<-DiferTSibl|>model(
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado2<-DiferTSibl%>%left_join(fitted(ModeloDummy,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado2$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Dummy") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#### Varios modelos al mismo tiempo
ajuste_final_models<-DiferTSibl%>%model(
`Fourier1DesempleoDiff`=ARIMA(value~fourier(K=1)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#1 componente de Fourier
`Fourier2DesempleoDiff`=ARIMA(value~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#2 componente de Fourier
`Fourier3DesempleoDiff`=ARIMA(value~fourier(K=3)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#3 componente de Fourier
`Fourier4DesempleoDiff`=ARIMA(value~fourier(K=4)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#4 componente de Fourier
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))#Ajuste dummy
)
glance(ajuste_final_models)
Modelo_serie_diff_models<-DiferTSibl%>%left_join(fitted(ajuste_final_models)|>group_by(.model)%>%
pivot_wider(names_from = .model, values_from = .fitted))
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "SerieDifOrd") %>%
add_trace(y = Modelo_serie_diff_models$Fourier1DesempleoDiff, mode = 'lines', line = list(color = 'blue'), name = "Fourier1") %>%
add_trace(y = Modelo_serie_diff_models$Fourier2DesempleoDiff, mode = 'lines', line = list(color = 'green'), name = "Fourier2") %>%
add_trace(y = Modelo_serie_diff_models$Fourier3DesempleoDiff, mode = 'lines', line = list(color = 'yellow'), name = "Fourier3") %>%
add_trace(y = Modelo_serie_diff_models$Fourier4DesempleoDiff, mode = 'lines', line = list(color = '#00CD66'), name = "Fourier4") %>%
add_trace(y = Modelo_serie_diff_models$DummyDesempleoDiff, mode = 'lines', line = list(color = 'purple'), name = "Dummy") %>%
layout(title = 'Tasa de Desempleo sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
DiferTSibl<-as_tsibble(Dif_ord_PIB)
DiferTSibl
###Explore diferentes valores de K
Modelo_serie_diff<-DiferTSibl|>model(
`Fourier1Desempleo`=ARIMA(value~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))#En este caso se hace con tres componentes de Fourier
)
real_ajustado1<-DiferTSibl%>%left_join(fitted(Modelo_serie_diff,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado1$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Armónico") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#####Ajuste Dummy
ModeloDummy<-DiferTSibl|>model(
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado2<-DiferTSibl%>%left_join(fitted(ModeloDummy,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado2$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Dummy") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#### Varios modelos al mismo tiempo
ajuste_final_models<-DiferTSibl%>%model(
`Fourier1DesempleoDiff`=ARIMA(value~fourier(K=1)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#1 componente de Fourier
`Fourier2DesempleoDiff`=ARIMA(value~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#2 componente de Fourier
`Fourier3DesempleoDiff`=ARIMA(value~fourier(K=3)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#3 componente de Fourier
`Fourier4DesempleoDiff`=ARIMA(value~fourier(K=4)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#4 componente de Fourier
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))#Ajuste dummy
)
glance(ajuste_final_models)
Modelo_serie_diff_models<-DiferTSibl%>%left_join(fitted(ajuste_final_models)|>group_by(.model)%>%
pivot_wider(names_from = .model, values_from = .fitted))
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "SerieDifOrd") %>%
add_trace(y = Modelo_serie_diff_models$Fourier1DesempleoDiff, mode = 'lines', line = list(color = 'blue'), name = "Fourier1") %>%
add_trace(y = Modelo_serie_diff_models$Fourier2DesempleoDiff, mode = 'lines', line = list(color = 'green'), name = "Fourier2") %>%
add_trace(y = Modelo_serie_diff_models$Fourier3DesempleoDiff, mode = 'lines', line = list(color = 'yellow'), name = "Fourier3") %>%
add_trace(y = Modelo_serie_diff_models$Fourier4DesempleoDiff, mode = 'lines', line = list(color = '#00CD66'), name = "Fourier4") %>%
add_trace(y = Modelo_serie_diff_models$DummyDesempleoDiff, mode = 'lines', line = list(color = 'purple'), name = "Dummy") %>%
layout(title = 'Tasa de Desempleo sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
DiferTSibl<-as_tsibble(Dif_ord_PIB)
DiferTSibl
###Explore diferentes valores de K
Modelo_serie_diff<-DiferTSibl|>model(
`Fourier1Desempleo`=ARIMA(value~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0))#En este caso se hace con tres componentes de Fourier
)
real_ajustado1<-DiferTSibl%>%left_join(fitted(Modelo_serie_diff,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado1$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Armónico") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#####Ajuste Dummy
ModeloDummy<-DiferTSibl|>model(
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))
)
real_ajustado2<-DiferTSibl%>%left_join(fitted(ModeloDummy,by=index))#%>%select(-.model)
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "Serie1") %>%
add_trace(y = real_ajustado2$.fitted, mode = 'lines', line = list(color = 'blue'), name = "Ajuste Dummy") %>%
layout(title = 'PIB Trimestral sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
#### Varios modelos al mismo tiempo
ajuste_final_models<-DiferTSibl%>%model(
`Fourier1DesempleoDiff`=ARIMA(value~fourier(K=1)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#1 componente de Fourier
`Fourier2DesempleoDiff`=ARIMA(value~fourier(K=2)+pdq(0, 0, 0) + PDQ(0, 0, 0)),#2 componente de Fourier
`DummyDesempleoDiff`=ARIMA(value~season()+pdq(0, 0, 0) + PDQ(0, 0, 0))#Ajuste dummy
)
glance(ajuste_final_models)
Modelo_serie_diff_models<-DiferTSibl%>%left_join(fitted(ajuste_final_models)|>group_by(.model)%>%
pivot_wider(names_from = .model, values_from = .fitted))
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "SerieDifOrd") %>%
add_trace(y = Modelo_serie_diff_models$Fourier1DesempleoDiff, mode = 'lines', line = list(color = 'blue'), name = "Fourier1") %>%
add_trace(y = Modelo_serie_diff_models$Fourier2DesempleoDiff, mode = 'lines', line = list(color = 'green'), name = "Fourier2") %>%
add_trace(y = Modelo_serie_diff_models$DummyDesempleoDiff, mode = 'lines', line = list(color = 'purple'), name = "Dummy") %>%
layout(title = 'Tasa de Desempleo sin tendencia (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
plot_ly(x = time(DiferenciaOrd), y = DiferenciaOrd, type = 'scatter', mode = 'lines', color = I("red"), name = "SerieDifOrd") %>%
add_trace(y = DiferenciaOrd-Modelo_serie_diff_models$Fourier1DesempleoDiff, mode = 'lines', line = list(color = 'blue'), name = "Fourier1") %>%
add_trace(y = DiferenciaOrd-Modelo_serie_diff_models$Fourier2DesempleoDiff, mode = 'lines', line = list(color = 'green'), name = "Fourier2") %>%
add_trace(y = DiferenciaOrd-Modelo_serie_diff_models$DummyDesempleoDiff, mode = 'lines', line = list(color = 'purple'), name = "Dummy") %>%
layout(title = 'Tasa de Desempleo sin tendencia y estacionalidad (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "SerieDifOrd") %>%
add_trace(y = DiferenciaOrd-Modelo_serie_diff_models$Fourier1DesempleoDiff, mode = 'lines', line = list(color = 'blue'), name = "Fourier1") %>%
add_trace(y = DiferenciaOrd-Modelo_serie_diff_models$Fourier2DesempleoDiff, mode = 'lines', line = list(color = 'green'), name = "Fourier2") %>%
add_trace(y = DiferenciaOrd-Modelo_serie_diff_models$DummyDesempleoDiff, mode = 'lines', line = list(color = 'purple'), name = "Dummy") %>%
layout(title = 'Tasa de Desempleo sin tendencia y estacionalidad (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
plot_ly(x = time(Dif_ord_PIB), y = Dif_ord_PIB, type = 'scatter', mode = 'lines', color = I("red"), name = "SerieDifOrd") %>%
add_trace(y = Dif_ord_PIB-Modelo_serie_diff_models$Fourier1DesempleoDiff, mode = 'lines', line = list(color = 'blue'), name = "Fourier1") %>%
add_trace(y = Dif_ord_PIB-Modelo_serie_diff_models$Fourier2DesempleoDiff, mode = 'lines', line = list(color = 'green'), name = "Fourier2") %>%
add_trace(y = Dif_ord_PIB-Modelo_serie_diff_models$DummyDesempleoDiff, mode = 'lines', line = list(color = 'purple'), name = "Dummy") %>%
layout(title = 'Tasa de Desempleo sin tendencia y estacionalidad (Diferencia Ordinaria, lag=1)',
xaxis = list(title = 'Mes', rangeslider = list(type = 'date')))
Train=ts(PIB3TS[1:61], start = c(2005, 1),frequency = 4)
Test=ts(PIB3TS[62:76],start=c(2020,2),frequency = 4)
h=1
lserie=length(PIB3TS)
ntrain=trunc(length(PIB3TS)*0.80)+1 ##% del datos en el conjunto de entrenamiento es del 80%.
ntrain
time(PIB3TS)
time(PIB3TS)[ntrain]###Me entrega la ultima fecha de la posición ntrain #Partiendo la serie en entrenamiento y test
train=window(PIB3TS,end=time(PIB3TS)[ntrain])
test=window(PIB3TS,start=time(PIB3TS)[ntrain]+1/4) ##1/4 porque es la fracción que corresponde a un trimestre
length(train)
ntest=length(test)
ntest ##Me define el valor de origins, o de ventanas de rolling.
lserie ### Comparar los valores
fchstepahe=matrix(0,nrow=ntest,ncol=h) ##Crea una Columna para los h-pasos adelante ### verval contiene los verdaderos valores de la serie en el conjunto de prueba con los que se compararán los pronósticos.
verval=cbind(test[1:ntest]) # Predicción un paso adelante
####Ajuste del modelo con los datos de entrenamiento
HWAP_train=stats::HoltWinters(train,gamma = 0)
HWAP_train$alpha
HWAP_train$beta ###Observación: Note que que esos son las estimaciones de los parámetros de suavizamiento. Se puede también hacer una grilla de valores para explorar si hay unos valores mejores. # por ejemplo como sigue:
require(utils)
suav_inputs=cbind(seq(0.001,0.999,0.1),seq(0.001,0.999,0.1))
colnames(suav_inputs)<-c("alpha","beta")
suav_inputs_tbl=tibble::as_tibble(suav_inputs)
grilla_suav=expand.grid(alpha=suav_inputs_tbl$alpha,beta=suav_inputs_tbl$beta) ##Grilla de Valores
####Se crean las ventanas de rolling y se obtiene los h-pronósticos para cada ventana(hay ntest posibles ventanas)
for(i in 1:(ntest)){x=window(PIB3TS,end=time(PIB3TS)[ntrain]+(i-1)/4)
print(length(x))
refit=stats::HoltWinters(x,gamma=0,alpha=HWAP_train$alpha,bet=HWAP_train$beta)
fchstepahe[i,]=as.numeric(forecast::forecast(refit,h=h)$mean) }
fchstepahe
errores_pred=verval -fchstepahe ##Observación: debo devolver los pronósticos y los verdaderos valores a la escala original si es necesario.
ECM=apply(errores_pred^2,MARGIN = 2,mean,na.rm=TRUE) ##Acá se computa la medida de precisión del pronóstico(en este caso ECM).
RECM=sqrt(ECM) ##Se le saca raíz
#RECM ##se lee: Primera fila RECM 1-paso adelante y así sucesivamente.
ECM
plot_ly(x = time(test), y = test, type = 'scatter', mode = 'lines', color = I("red"), name = "PIB") %>%
add_trace(y = fchstepahe, mode = 'lines', line = list(color = 'blue'), name = "Predicciones") %>%
layout(title = 'PIB vs Predicciones (Abril 2020-Diciembre 2023)',          xaxis = list(title = 'Trimestre', rangeslider = list(type = 'date')))
library(forecast)
library(greybox)
HWAP_train=stats::HoltWinters(train,gamma=0)
h=1
ourCallETS <- "forecast::forecast(stats::HoltWinters(x=data,alpha=HWAP_train$alpha,beta=HWAP_train$beta,gamma=0),h=h)" ###Note que x=data es solo un argumento indeterminado.
ourValueETS <- c("mean","lower","upper")
origins=ntest   ##número de rolling windows
Valoresretornados1 <- ro(PIB3TS, h=h, origins=origins, call=ourCallETS, value=ourValueETS,ci=FALSE,co=FALSE)
t(Valoresretornados1$holdout)## Permiten verificar los verdaderos valores h-pasos adelante.
t(Valoresretornados1$mean)
apply((Valoresretornados1$holdout -Valoresretornados1$mean)^2,1,mean,na.rm=TRUE) ### Se calcula el error cuadrático medio de predicción
h=1
lserie=length(PIB3TS)
ntrain=trunc(length(PIB3TS)*0.80)+1 ##% del datos en el conjunto de entrenamiento es del 80%.
ntrain
time(PIB3TS)
time(PIB3TS)[ntrain]###Me entrega la ultima fecha de la posición ntrain #Partiendo la serie en entrenamiento y test
train=window(PIB3TS,end=time(PIB3TS)[ntrain])
test=window(PIB3TS,start=time(PIB3TS)[ntrain]+1/4) ##1/4 porque es la fracción que corresponde a un trimestre
length(train)
ntest=length(test)
ntest ##Me define el valor de origins, o de ventanas de rolling.
lserie ### Comparar los valores
fchstepahe=matrix(0,nrow=ntest,ncol=h) ##Crea una Columna para los h-pasos adelante ### verval contiene los verdaderos valores de la serie en el conjunto de prueba con los que se compararán los pronósticos.
verval=cbind(test[1:ntest]) # Predicción un paso adelante
####Ajuste del modelo con los datos de entrenamiento
HWAP_train=stats::HoltWinters(train,gamma = 0)
HWAP_train$alpha
HWAP_train$beta ###Observación: Note que que esos son las estimaciones de los parámetros de suavizamiento. Se puede también hacer una grilla de valores para explorar si hay unos valores mejores. # por ejemplo como sigue:
require(utils)
suav_inputs=cbind(seq(0.001,0.999,0.1),seq(0.001,0.999,0.1))
colnames(suav_inputs)<-c("alpha","beta")
suav_inputs_tbl=tibble::as_tibble(suav_inputs)
grilla_suav=expand.grid(alpha=suav_inputs_tbl$alpha,beta=suav_inputs_tbl$beta) ##Grilla de Valores
####Se crean las ventanas de rolling y se obtiene los h-pronósticos para cada ventana(hay ntest posibles ventanas)
for(i in 1:(ntest)){x=window(PIB3TS,end=time(PIB3TS)[ntrain]+(i-1)/4)
print(length(x))
refit=stats::HoltWinters(x,gamma=0,alpha=HWAP_train$alpha,bet=HWAP_train$beta)
fchstepahe[i,]=as.numeric(forecast::forecast(refit,h=h)$mean) }
fchstepahe
errores_pred=verval -fchstepahe ##Observación: debo devolver los pronósticos y los verdaderos valores a la escala original si es necesario.
ECM=apply(errores_pred^2,MARGIN = 2,mean,na.rm=TRUE) ##Acá se computa la medida de precisión del pronóstico(en este caso ECM).
RECM=sqrt(ECM) ##Se le saca raíz
#RECM ##se lee: Primera fila RECM 1-paso adelante y así sucesivamente.
ECM
apply((Valoresretornados1$holdout -Valoresretornados1$mean)^2,1,mean,na.rm=TRUE) == ECM
#'c': Se ajusta una constante (serie estacionaria alrededor de una media constante).
#'ct': Se ajusta una constante y una tendencia lineal (serie estacionaria alrededor de una tendencia lineal).
#'nc': No se ajusta ni constante ni tendencia (serie estacionaria sin media constante ni tendencia).
#lremesas porque tocó hacer transformación boxcox
#Prueba Dickey-Fuller
#Hipótesis nula (H0): La serie tiene una raíz unitaria (no es estacionaria).
#Hipótesis alternativa (H1): La serie no tiene una raíz unitaria (es estacionaria).
fUnitRoots::adfTest(PIB3TS,lags = 4,type='nc')
#P-valor 0.78, lo que indica presencia de raíz unitaria, por lo que toca hacer diferenciación
dif_PIB <- diff(PIB3TS)
#El número de retardos debe cambiar en cada transformación o dejamos siempre los del original
fUnitRoots::adfTest(dif_PIB,lags = 4,type='nc')
#p-valor 0.01, con la transformación la serie ya es estacionaria
modelo_automatico<-auto.arima(dif_PIB,d=0,D=0,max.p=5,max.q=5,start.p=0, start.q=0,seasonal=FALSE,max.order=10,stationary=TRUE,ic="aic",stepwise=FALSE,allowmean = TRUE)
modelo_automatico
modelo_ajustado<-forecast::Arima(PIB3TS,order = c(0,1,3),lambda = LambdaPIB,include.constant = TRUE)
summary(modelo_ajustado)
coeftest(modelo_ajustado)
#drift no es significativo así que usamos fixed; fixed(AR,MA,drift o constante), NA para estimar, 0 para no estimar
modelo_ajustado<-forecast::Arima(PIB3TS,order = c(0,1,3),lambda = LambdaPIB,include.constant = TRUE, fixed = c(0,NA,0,NA))
summary(modelo_ajustado)
coeftest(modelo_ajustado)
residuales=modelo_ajustado$residuals
plot(residuales)
#plot(SDresiduales)
acf(residuales,lag.max = 48)
pacf(residuales)
#Test de normalidad
#La hipótesis nula H0 es que los datos siguen una distribución normal.
#La hipótesis alternativa H1 es que los datos no siguen una distribución normal.
jarque.bera.test(residuales)
#P-valor de 0.000000346, por lo tanto los datos no siguen una distribución normal
#Test de autocorrelación
#Lags empiricamente se calcula como la raiz cuadrada del tamaño de muestra o si hay estacionalidad, se ingresa el periodo estacional, digamos en una mensual con estacionalidad anual colocamos 12 lags
#fitdf es la cantidad de parametros estimados en el modelo ARIMA (incluyendo el fidth(constante)), en este caso solo 2.
Box.test(residuales, lag = ceiling(sqrt(length(residuales))) , type = "Ljung-Box", fitdf = 2)
#H0:Los residuos son independientes y no están autocorrelacionados (es decir, la serie temporal ajustada es adecuada).
#H1: Los residuos presentan autocorrelación, lo que sugiere que el modelo no captura toda la estructura temporal de los datos.
#P-valor 0.7482, por lo tanto los residuos son independientes y no estan autocorrelocionados
monthplot(residuales)
spectrum(residuales,spans = c(3,5)) #3 menos suavizado que 5
###Estadisticas CUSUM
res=residuales
cum=cumsum(res)/sd(res)
N=length(res)
cumq=cumsum(res^2)/sum(res^2)
Af=0.948 ###Cuantil del 95% para la estadistica cusum (valor común usado)
co=0.14013####Valor del cuantil aproximado para cusumsq para n/2 (valor común usado)
LS=Af*sqrt(N)+2*Af*c(1:length(res))/sqrt(N)
LI=-LS
LQS=co+(1:length(res))/N
LQI=-co+(1:length(res))/N
plot(cum,type="l",ylim=c(min(LI),max(LS)),xlab="t",ylab="",main="CUSUM")
lines(LS,type="S",col="red")
lines(LI,type="S",col="red")
#CUSUMSQ
plot(cumq,type="l",xlab="t",ylab="",main="CUSUMSQ")
lines(LQS,type="S",col="red")
lines(LQI,type="S",col="red")
#####Fase de Pronósticos
#h la cantidad de periodos adelante que desea pronosticar
pronosticos_PIB=forecast::forecast(modelo_ajustado,h=4,level=0.95)
plot(pronosticos_PIB)
#####Fase de Pronósticos
#h la cantidad de periodos adelante que desea pronosticar
pronosticos_PIB=forecast::forecast(modelo_ajustado,h=1,level=0.95)
plot(pronosticos_PIB)
h=1
lserie=length(PIB3TS)
ntrain=trunc(length(PIB3TS)*0.8)
ntrain
time(PIB3TS)
time(PIB3TS)[ntrain]###Me entrega la ultima fecha de la posicion ntrain
train=window(PIB3TS,end=c(2019,4))
test=window(PIB3TS,start=c(2020,1))
length(train)
ntest=length(test)
ntest
fcmat=matrix(0,nrow=ntest,ncol=h)
for(i in 1:ntest)
{
x=window(PIB3TS,end=c(2019,4)+(i-1)/4)
print(length(x))
refit=forecast::Arima(x,order = c(0,1,3),lambda = LambdaPIB,include.constant = TRUE, fixed = c(0,NA,0,NA))
fcmat[i,]=test[i]-forecast(refit,h=h)$mean
}
fcmat
ECM=mean(fcmat^2)
ECM
h=1
lserie=length(PIB3TS)
ntrain=trunc(length(PIB3TS)*0.8)
ntrain
time(PIB3TS)
time(PIB3TS)[ntrain]###Me entrega la ultima fecha de la posicion ntrain
train=window(PIB3TS,end=c(2019,4))
test=window(PIB3TS,start=c(2020,1))
length(train)
ntest=length(test)
ntest
fcmat=matrix(0,nrow=ntest,ncol=h)
for(i in 1:ntest)
{
x=window(PIB3TS,end=c(2019,4)+(i-1)/4)
print(length(x))
refit=forecast::Arima(x,order = c(0,1,3),lambda = LambdaPIB,include.constant = TRUE, fixed = c(0,NA,0,NA))
fcmat[i,]=test[i]-forecast(refit,h=h)$mean
}
fcmat
ECM=mean(fcmat^2)
ECM
test_graf <- data.frame(Tiempo = time(test),Valor_real = as.numeric(test),Valor_prono = as.numeric(test) - as.vector(fcmat))
ggplot(test_graf, aes(x = Tiempo)) +
geom_line(aes(y = Valor_real, color = "Serie Real"), size = 1) +
geom_line(aes(y = Valor_prono, color = "Pronóstico"), linetype = "dashed", size = 1) +
scale_color_manual(values = c("Serie Real" = "blue", "Pronóstico" = "red")) +
labs(title = "Comparación de la Serie de Tiempo Real y el Pronóstico",
x = "Tiempo",
y = "Valor",
color = "Leyenda") + theme_minimal()
coef=coefs2poly(modelo_ajustado)
coef
outliers=tsoutliers::locate.outliers(res,coef)
outliers
xreg = outliers.effects(outliers, length(PIB3TS))
xreg
modelo_ajustado2<-forecast::Arima(PIB3TS,order = c(0,1,3), xreg = xreg,lambda = LambdaPIB,include.constant = TRUE)
#, fixed = c(NA,NA,0)
modelo_ajustado2
coeftest(modelo_ajustado2)
res_2=modelo_ajustado2$residuals
coef_2=coefs2poly(modelo_ajustado2)
outliers_2 = locate.outliers(res_2,coef_2,cval=3.5)###cval=3.5 por defecto
outliers_2
xreg_2 = outliers.effects(outliers_2, length(PIB3TS))
xreg_2
xreg_final<-cbind(xreg[,1:3],xreg_2,xreg[,4:8])
xreg_final
modelo_ajustado3<-forecast::Arima(PIB3TS,order = c(0,1,3), xreg = xreg_final,lambda = LambdaPIB,include.constant = TRUE)
#, fixed = c(NA,NA,0)
modelo_ajustado3
coeftest(modelo_ajustado3)
res_3=modelo_ajustado3$residuals
coef_3=coefs2poly(modelo_ajustado3)
outliers_3 = locate.outliers(res_3,coef_3,cval=3.5)###cval=3.5 por defecto
outliers_3
###Creación de las variable de intervención
pasos_adel=4
num_outliers=dim(xreg_final)[2]
regresoras_aditivos=matrix(c(rep(0,pasos_adel*(num_outliers-6))),pasos_adel,num_outliers-6)
regresoras_LS=matrix(c(rep(1,pasos_adel*(num_outliers-4))),pasos_adel,num_outliers-4)
regresoras_TC=matrix(c(rep(0,pasos_adel*(num_outliers-8))),pasos_adel,num_outliers-8)
regresoras=cbind(regresoras_aditivos,regresoras_LS,regresoras_TC)
colnames(regresoras)=colnames(xreg_final)
pronostico_out=forecast(object=modelo_ajustado3,xreg=regresoras,h=pasos_adel)
pronostico_out
plot(pronostico_out)
###Creación de las variable de intervención
pasos_adel=1
num_outliers=dim(xreg_final)[2]
regresoras_aditivos=matrix(c(rep(0,pasos_adel*(num_outliers-6))),pasos_adel,num_outliers-6)
regresoras_LS=matrix(c(rep(1,pasos_adel*(num_outliers-4))),pasos_adel,num_outliers-4)
regresoras_TC=matrix(c(rep(0,pasos_adel*(num_outliers-8))),pasos_adel,num_outliers-8)
regresoras=cbind(regresoras_aditivos,regresoras_LS,regresoras_TC)
colnames(regresoras)=colnames(xreg_final)
pronostico_out=forecast(object=modelo_ajustado3,xreg=regresoras,h=pasos_adel)
pronostico_out
plot(pronostico_out)
View(PIB3)
View(PIB3TSibble)
fc_PIB <- window(fitted(modelo_ajustado3), start=c(2020,2))
esta_param_modelo<-coef(modelo_ajustado3)
h <- 1
train = window(PIB3TS,end=time(PIB3TS)[ntrain])
test = window(PIB3TS,start=time(PIB3TS)[ntrain]+1/4)
n <- length(test) - h + 1
fitmodelo <- update(modelo_ajustado3,fixed=esta_param_modelo)
fc <- ts(numeric(n), start=c(2020,2), freq=4)
for(i in 1:n)
{
x <- window(PIB3TS, end=c(2020, 1+(i-1)))
refit <- forecast::Arima(x, model=fitmodelo, xreg = xreg[1:(60+(i-1)),])
fc[i] <- forecast::forecast(refit, h=h,xreg = t(as.matrix(xreg[(60+i),])))$mean[h]
}
fc_PIB <- window(fitted(modelo_ajustado3), start=c(2020,2))
esta_param_modelo<-coef(modelo_ajustado3)
h <- 1
train = window(PIB3TS,end=time(PIB3TS)[ntrain])
test = window(PIB3TS,start=time(PIB3TS)[ntrain]+1/4)
n <- length(test) - h + 1
fitmodelo <- update(modelo_ajustado3,fixed=esta_param_modelo)
fc <- ts(numeric(n), start=c(2020,2), freq=4)
for(i in 1:n)
{
x <- window(PIB3TS, end=c(2020, 2+(i-1)))
refit <- forecast::Arima(x, model=fitmodelo, xreg = xreg[1:(60+(i-1)),])
fc[i] <- forecast::forecast(refit, h=h,xreg = t(as.matrix(xreg[(60+i),])))$mean[h]
}
fc_PIB <- window(fitted(modelo_ajustado3), start=c(2020,2))
esta_param_modelo<-coef(modelo_ajustado3)
h <- 1
train = window(PIB3TS,end=time(PIB3TS)[ntrain])
test = window(PIB3TS,start=time(PIB3TS)[ntrain]+1/4)
n <- length(test) - h + 1
fitmodelo <- update(modelo_ajustado3,fixed=esta_param_modelo)
fc <- ts(numeric(n), start=c(2020,2), freq=4)
for(i in 1:n)
{
x <- window(PIB3TS, end=c(2020, 1+(i-1)))
refit <- forecast::Arima(x, model=fitmodelo, xreg = xreg[1:(61+(i-1)),])
fc[i] <- forecast::forecast(refit, h=h,xreg = t(as.matrix(xreg[(61+i),])))$mean[h]
}
fc_PIB <- window(fitted(modelo_ajustado), start=c(2020,2))
esta_param_modelo<-coef(modelo_ajustado)
h <- 1
train = window(PIB3TS,end=time(PIB3TS)[ntrain])
test = window(PIB3TS,start=time(PIB3TS)[ntrain]+1/4)
n <- length(test) - h + 1
fitmodelo <- update(modelo_ajustado,fixed=esta_param_modelo)
fc <- ts(numeric(n), start=c(2020,2), freq=4)
for(i in 1:n)
{
x <- window(PIB3TS, end=c(2020, 1+(i-1)))
refit <- forecast::Arima(x, model=fitmodelo, xreg = xreg[1:(61+(i-1)),])
fc[i] <- forecast::forecast(refit, h=h,xreg = t(as.matrix(xreg[(61+i),])))$mean[h]
}
x <- window(PIB3TS, end=c(2020, 1+(i-1)))
refit <- forecast::Arima(x, model=fitmodelo, xreg = xreg[1:(61+(i-1)),])
